
#include <ansi.h>
inherit F_CLEAN_UP;

int main(object me, string arg)
{
	object room,room2,who,*mem;
	int pwd, i, j,count, max_exp, combatexp;
	string name; 

	seteuid(getuid());
	
	// This is the primary quest owner 
	if (me->query("private_maze/destination") == base_name(environment(me))+".c"
		 && me->query("quest/quest")== "ɮ"
		 && me->query("private_maze/create")) {
		
		me->set("private_maze/create",0);	// Ϊ٣ʱowner˳ԱcreateĴ
		
		room2 = find_object("/obj/dungeon/standardmaze/"+me->query("id")+"/entry");
		if (!room2)
			room2=load_object("/obj/dungeon/standardmaze/"+me->query("id")+"/entry");
		if (!room2)	
			room2="/obj/dungeon/standardmaze"->query_maze_room(me->query("id")+"/entry");
		if (!room2) {
			write("Oops.Please report to wizards. \n");	
			return 1;
		}
		// If it's the first time, prepare the instance parameters for other people's entry.
		if (!room2->query("maze/pwd"))	{
			
			// Maze_exp ڶߵľֵе˿϶ܰæ
			mem = pointerp(me->query_team()) ? me->query_team() : ({ me });
    		j = sizeof (mem);
    		while (j--)	{
				if (mem[j]) {
		    		max_exp = mem[j]->query("combat_exp");
		    		if (max_exp > 15000000) max_exp = 15000000;
		    		combatexp = (max_exp>combatexp) ? max_exp : combatexp;
				}
    		}
			room2->set("maze/exp", 	combatexp); 			

			room2->set("maze/type", me->query("private_maze/type"));
			room2->set("maze/exit", me->query("private_maze/destination"));
			room2->set("maze/name", me->query("private_maze/orig_name"));
			room2->set("maze/sig",	me->query("private_maze/maze"));

					room2->query("maze/sig")->set_link_exit_room(room2->query("maze/exit"));
					room2->query("maze/sig")->set_link_entry_room(room2->query("maze/exit"));

			room2->set("maze/boss",		"/obj/dungeon/boss");	
			room2->set("maze/blocker",	"/obj/dungeon/blocker");	
			room2->set("maze/npc_pfm_chance", me->query("private_maze/difficulty"));
						
		}
		// Owner can change password  anytime he enters
		if (arg)	pwd = atoi(arg);
		if (!pwd)	pwd = 123;
		room2->set("maze/pwd", pwd);
		
		count = sizeof(room2->get_players());
		if (count >= room2->query("maze/type"))
			return notify_fail("Ϊܣ˶࣬Ѳٽˡ\n");
		
//		me->set_temp("maze_entry",environment(me));	
				
		me->move(room2);
		write(WHT"\n봹˵" + me->query("private_maze/orig_name")+ "Ϊ"+ pwd +"\n"NOR);
		return 1;	
	}
	
	// Following is for other ppl's entry
	
	if (!arg || sscanf(arg, "%s %d", name, pwd)!= 2)
		return notify_fail("ʽΪ entermaze Ӣ 룬 entermaze abcd 249 \n");
		
	if (!name || !pwd)
		return notify_fail("ʽΪ entermaze Ӣ 룬 entermaze abcd 249 \n");
		
	room2 = find_object("/obj/dungeon/standardmaze/"+name+"/entry");
	if (!room2)
		return notify_fail("˵ûָ\n");
		
	if (!room2->query("maze/pwd"))
		return notify_fail("ҪӵȽ롣\n");
		
	if (room2->query("maze/pwd") != pwd)
		return notify_fail("벻ԣ޷ָ\n");
		
	if (F_LEVEL->get_level(me->query("combat_exp")) > F_LEVEL->get_level(room2->query("maze/exp")) +5)
		return notify_fail("ߵȼܳ"+ (F_LEVEL->get_level(room2->query("maze/exp"))+5)+"\n");
	
	count = sizeof(room2->get_players());
	
	if (count >= room2->query("maze/type"))
		return notify_fail("Ϊܣ˶࣬Ѳٽˡ\n");
		
	me->set_temp("maze_entry",environment(me));	
	me->move(room2);
	
	write(WHT"\n˳"+ room2->query("mark_ob") + "ģ" + room2->query("maze/name")+ "ǳ״ݻ\n"NOR);
	return 1;
}

int help (object me)
{
	write(@HELP
[0;1;37m[0m
[1;36m		entermaze [name] [password]	
[0;1;37m[0m   
 
ɽԼ˵
ɷƳĴ˸
ӵѰҵصص㣬ʹøܽһ

ڳ˵ֻ entermaze ܽ

ͬвͬƣڸʱ˵
޸ߵģѶȾͻһЩȻҲߡ

̫ѣЩôҪһ
˵ص룬Ϊ entermaze password
˵ entermaze 890 趨Ϊ 890
㲻趨ϵͳԶΪ123Ҳ˵˲
entermaze˿123룩

İֽΪ entermaze name password
nameΪߵӢpasswordΪ趨롣

󣬽ɵʱڸ˷

ûƣֻҪ֪룬ʹڶеģֻҪ
ڶ飬Ҳܽ롣Ҳ˵ʹڵɣ
̫ѣʱæ

һڣӣʱ䵽ɺԶ٣ʱ
ˡʬƶڷ䡣


[0;1;37m[0m    
HELP
	);
	return 1;
}

